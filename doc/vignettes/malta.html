<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Stuctural analyzis of Malta reed warbler data</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Stuctural analyzis of Malta reed warbler data</h1>

<p>First install the <em>layeranalyzer</em> package. If you have <em>devtools</em> installed,
this can be achived by the command:</p>

<blockquote>
<p>install_github(repo=&ldquo;trondreitan/layeranalyzer&rdquo;, build_vignettes=TRUE)</p>
</blockquote>

<p>If devtools is not available, you need to reference the correct version:</p>

<blockquote>
<p>install.packages(&ldquo;<a href="https://github.com/trondreitan/layeranalyzer/raw/master/layeranalyzer_0.1.0.tar.gz%22,type=%22source%22,verbose=T">https://github.com/trondreitan/layeranalyzer/raw/master/layeranalyzer_0.1.0.tar.gz&rdquo;,type=&ldquo;source&rdquo;,verbose=T</a>, build_vignettes=TRUE)</p>
</blockquote>

<p>The personal web page has newer &ldquo;bleeding edge&rdquo; versions of the package:</p>

<blockquote>
<p>install.packages(&ldquo;<a href="https://folk.uio.no/trondr/R/layeranalyzer_0.1.0.tar.gz%22,type=%22source%22,verbose=T">https://folk.uio.no/trondr/R/layeranalyzer_0.1.0.tar.gz&rdquo;,type=&ldquo;source&rdquo;,verbose=T</a>, build_vignettes=TRUE)</p>
</blockquote>

<h1>If the package is installed, load it:</h1>

<pre><code class="r">library(layeranalyzer)
</code></pre>

<p>Usually, the next thing to happen would be for the data to be read:</p>

<blockquote>
<p>malta=read.table(&ldquo;malta.csv&rdquo;,sep=&ldquo;;&rdquo;,header=T)
However, this particular dataset is already in the package.</p>
</blockquote>

<p>We will now defined the Bayesian prior for teh parameters. This
may seem a bit unnecessary, since the analysis is classic (ML-based),
but MCMC sampling is needed to provide the maximum likelihood
optimization with good starting points.</p>

<p>##Priors:
Initial values have a larger prior interval than the mean
in order to represent that the process might not start in equilibrium.
Wide priors for stochastic term and noise standard deviation.
characteristic time (dt) set to having a lower limit right below the
time resolution and upper limit comparable to the data length.
Priors are not so important when the analysis is classic, but
since the ML optimization starts from MCMC samples, a good prior
can give the optimization a good start.</p>

<pre><code class="r">p=layer.prior(mu=c(log(1),log(1000)),init=c(log(0.1),log(10000)),dt=c(0.5,20),sigma=c(0.01,2),obs=c(0.01,1),lin=c(-0.1,0.1))
</code></pre>

<h2>Define the time series</h2>

<p>Time points, values and in this case also sample standard deviations
and sample size, used for calculating standard errors for each measurement).</p>

<pre><code class="r">X=layer.data.series(time.points=malta$Time.Year,
  value.points=malta$Mean..log.body.mass.,
  std.dev=sqrt(malta$Variance.calculated.from.the.data), 
  num.meas.per.value=malta$Sample.size,name=&quot;log.body.size&quot;)
</code></pre>

<p>We will now plot data, to see if it makes sense:</p>

<pre><code class="r">plot(X$time, X$value,type=&quot;b&quot;,ylim=c(2.2,2.7))
for(i in 1:length(X$time))
  lines(c(X$time[i],X$time[i]),
        c(X$value[i]-1.96*X$std.dev[i]/sqrt(X$num.meas.per.value[i]),
          X$value[i]+1.96*X$std.dev[i]/sqrt(X$num.meas.per.value[i])))
</code></pre>

<h2>Call &#39;traverse.standalone.layered&#39;</h2>

<p>in order to automatically go through all process structures up to a
given complexity (max layers=2). do.maximum.likelihood = TRUE sets
ML-based estimation in stead of Bayesian inference, while
maximum.likelihood.numstart = 1000 sets the number of ML
optimizations performed (starting at different MCMC samples).</p>

<p>Note that initial value treatment is automatically used when
non-stationary models are among the possible candidates.
This is because the likelihood of the first measurement would
otherwise be determined by the stationary distribution of
the process, which is not available for non-stationary models.</p>

<p>PS: This will take a while:</p>

<pre><code class="r">models.ml=traverse.standalone.layered(X, max.layers=2, 
  talkative=TRUE, allow.one.feedback.loop=TRUE, 
  just.stationary=FALSE, no.rw=FALSE,    
  time.integrals.possible=FALSE, 
  allow.deterministic.layers=TRUE,
  do.maximum.likelihood = TRUE, maximum.likelihood.numstart = 1000, 
  num.MCMC=1000,spacing=10,burnin=2000, num.temp = 4, prior=p)
</code></pre>

<h2>Compare using AICc:</h2>

<pre><code class="r">compare.layered(models.ml, ML.IC = &quot;AICc&quot;)
</code></pre>

<p>This will output something like the following:  </p>

<pre><code class="r">#weight=-0.5*AICc Post. Prob.(%)  
#Model   1         29.35569       16.57780  
#Model   2         23.78279        0.06299  
#Model   3         30.48248       51.15449  
#Model   4         26.14139        0.66615  
#Model   5         23.64615        0.05494  
#Model   6         29.46821       18.55215  
#Model   7         26.88072        1.39528  
#Model   8         25.92793        0.53811  
#Model   9         27.67578        3.08994  
#Model  10         25.07575        0.22949  
#Model  11         22.65920        0.02048  
#Model  12         28.51285        7.13650  
#Model  13         25.89695        0.52169  
</code></pre>

<p>Use &ldquo;summary(models.ml[[1]])&rdquo; (for instance) to look at the
parameter names and thus see what kind of model it is.</p>

<p>PS: There may be some variation in the results as the estimation
has some level of stochasticity.</p>

<h2>It turns out that the best model is linear trend OU.</h2>

<p>Make a summary:</p>

<pre><code class="r">summary(models.ml[[3]])
</code></pre>

<p>Output:</p>

<pre><code class="r">#Coefficients:  
#                         ML estimate Bayesian Lower 95% Bayesian Upper 95%  
#mu_log.body.size            2.335158          -2.309826           2.483512  
#lin_t_log.body.size         0.007669          -0.044273           0.904957  
#dt_log.body.size_1          2.518253           2.211906         416.657806  
#sigma_log.body.size_1       0.000324           0.002351           0.052827  
#init_log.body.size_l1_s0    2.622032           2.490479           2.670063  
#  
#Log-likelihood:    36.937  
#AIC :   -63.874  
#AICc:   -61.147  
#BIC :   -59.708  
</code></pre>

<h2>Extra:</h2>

<p>Take a further look at OU+linear trend:</p>

<p>Look at Bayesian analysis, in order to get process inference:</p>

<pre><code class="r">X.mod3=layer.series.structure(X, numlayers=1,
        lin.time=T, prior=p, init.time=1996) 
mod3=layer.analyzer(X.mod3, num.MCMC=1000, burnin=10000,spacing=10,num.temp=6,
  do.model.likelihood = FALSE, 
  smoothing.specs=list(do.smoothing=TRUE, smoothing.time.diff=1, 
                       smoothing.start=1996, smoothing.end=2020.5,
               num.smooth.per.mcmc=10))
</code></pre>

<p>Make plot of measurements, process inference estimate and
process inference uncertainty:</p>

<pre><code class="r">png(&quot;malta.png&quot;,height=800,width=100)
par(cex=1.2)

## Plot data points:
plot(X$time, X$value,type=&quot;b&quot;,ylim=c(2.2,2.7),xlim=c(1996,2020),
    xlab=&quot;year&quot;,ylab=&quot;log(size)&quot;)

## Plot measurement uncertainties:
for(i in 1:length(X$time))
  lines(c(X$time[i],X$time[i]),
        c(X$value[i]-1.96*X$std.dev[i]/sqrt(X$num.meas.per.value[i]),
          X$value[i]+1.96*X$std.dev[i]/sqrt(X$num.meas.per.value[i])))
</code></pre>

<p>Plot process expectation value as a function of time:
PS: The &#39;mu&#39; parameter is in this case the intercept of the
line at the mean measurement time.
PSS: The expected value will lag one characteristic time behind
the line that it is tracking, thus the subtraction of the characteristic 
time here.</p>

<pre><code class="r">abline(c(models.ml[[3]]$mu_log.body.size$ML-models.ml[[3]]$lin_t_log.body.size$ML*((max(X$time)+min(X$time))/2 + models.ml[[3]]$dt_log.body.size_1$ML), models.ml[[3]]$lin_t_log.body.size$ML),lwd=3)

lines(mod3$process.time.points,mod3$process.mean, col=&quot;red&quot;,lwd=3)
lines(mod3$process.time.points,mod3$process.lower95, col=&quot;green&quot;,lwd=3)
lines(mod3$process.time.points,mod3$process.upper95, col=&quot;green&quot;,lwd=3)

dev.off()
</code></pre>

<h2>Look at residuals:</h2>

<p>Define the linear trend OU structure:</p>

<pre><code class="r">X.mod3=layer.series.structure(X, numlayers=1,
        lin.time=T, prior=p, init.time=1996)
</code></pre>

<p>Look at classic  analysis again:</p>

<pre><code class="r">mod3=layer.analyzer(X.mod3, num.MCMC=1000, burnin=10000,spacing=10,num.temp=6,
  do.model.likelihood = TRUE,maximum.likelihood.numstart=100,
  return.residuals=TRUE)
</code></pre>

<p>Look for auto-correlation:
Raw  plot:</p>

<pre><code class="r">plot(mod3$residuals.time, 
  mod3$standardized.residuals,type=&quot;b&quot;,xlab=&quot;Time&quot;, ylab=&quot;Residuals&quot;)
</code></pre>

<p>Partial auto-correlation plot:</p>

<pre><code class="r">pacf(mod3$standardized.residuals)
</code></pre>

<p>Rest for autocorrelation as linear regression analysis:</p>

<pre><code class="r">n=length(mod3$standardized.residuals)
summary(lm(mod3$standardized.residuals[2:n]~mod3$standardized.residuals[1:(n-1)]))
</code></pre>

<p>Output:  </p>

<pre><code class="r">#Coefficients:  
#                                       Estimate Std. Error t value Pr(&gt;|t|)  
#(Intercept)                             0.10778    0.22092   0.488    0.633  
#mod3$standardized.residuals[1:(n - 1)] -0.07367    0.26731  -0.276    0.787  
</code></pre>

<p>Is there time trend for residuals?</p>

<pre><code class="r">t=X$time-2000
summary(lm(mod3$standardized.residuals~t))
</code></pre>

<p>Output:  </p>

<pre><code class="r">#t           -0.003547   0.035994  -0.099    0.923  
</code></pre>

<p>So, no linear trend detected.  </p>

<p>Look at non-linear trends using GAM:</p>

<pre><code class="r">library(mgcv)
summary(gam(mod3$standardized.residuals~s(t)))
</code></pre>

<p>Output:  </p>

<pre><code class="r">#Approximate significance of smooth terms:  
#       edf Ref.df     F p-value  
#s(t) 1.474  1.807 0.206   0.778  
</code></pre>

<p>No non-linear trend detected either</p>

<p>Look for whether the distribution is normal:</p>

<pre><code class="r">qqnorm(mod3$standardized.residuals)
qqline(mod3$standardized.residuals)
shapiro.test(mod3$standardized.residuals)
</code></pre>

<p>Output: </p>

<pre><code class="r">#  p-value = 0.2262  
</code></pre>

<p>Looks like normality is okay.  </p>

<p>Look on prior expected values vs residuals for each series:</p>

<pre><code class="r">x1=mod3$prior.expected.values[,1]
plot(x1,mod3$standardized.residuals)
summary(lm(mod3$standardized.residuals~x1))
</code></pre>

<p>Output:  </p>

<pre><code class="r">#             Estimate Std. Error t value Pr(&gt;|t|)  
# (Intercept)    4.125      6.931   0.595    0.561  
# x1            -1.706      2.903  -0.588    0.565  
</code></pre>

<p>No discernable dependency between prior expected values and
standardized residuals.</p>

</body>

</html>
